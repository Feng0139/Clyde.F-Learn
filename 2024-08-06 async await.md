

# async 和 await 
## 作用
`async` 和 `await` 用于简化异步编程的关键词。可以让其写看起来像同步代码的异步代码，从而使代码易于阅读、编写和维护。

`async` 在方法返回值类型进行标记，代表此方法是异步方法，方法体内可以使用 `await` 关键词。
`await` 用于等待异步任务完成，让异步流程回到同步上，避免传统回调复杂性。

## 机制
### 任务调度器 Task Scheduler
它负责安排和管理任务的执行。它决定了什么时候、在什么线程上执行任务。默认情况下会重复使用线程池的线程去执行不同任务。

1. 默认任务调度器
	1. `TaskScheduler.Default`默认情况下使用线程池执行任务，旨在复用线程来提高性能。
	2. 适合短期的任务，如果长期执行会占用可用资源，等于降低效率。
	3. 设置`TaskCreationOptions.LongRunning`选项，任务调度器通常会为该任务创建新线程来执行任务，避免阻塞线程池中的线程资源。
2. 同步上下文调度器
	1. `SynchronizationContext`允许任务在特定的上下文线程中继续执行代码。
	2. 当任务捕获上下文，暂停恢复后会尝试分配到原先线程继续执行后续代码。
3. 自定义任务调度器
	1. 通过继承 `TaskScheduler` 类并重写 `QueueTask`、`TryExecuteTaskInline` 和 `GetScheduledTasks` 方法，可以实现自定义的调度逻辑。
4. 并行任务调度器
	1. `ConcurrentExclusiveSchedulerPair`提供一种可以并行和独占任务的机制。
	2. 允许创建并行和独占执行两个调度器，通常用于需要严格控制任务顺序和并发的场景。

### await 和任务调度器的关系
当 `Async` 方法使用 `await` 等待某个 `Task` 完成时，`await` 会执行下述操作：
1. 检查 `Task` 状态
	- 如果已经完成，那么继续执行后面的代码。
	- 如果未完成，会将此 `Async` 方法暂停，释放其载体线程，同时任务调度器会记住 `Async` 方法暂停的状态。继续下个步骤。
2. 线程控制权返回
	- 返回给线程池或者新的调用者，执行其它任务。
3. `Task` 完成后
	- `await` 会检查是否捕获了上下文，尝试在原先的上下文线程中恢复执行代码。
	- 如若捕获上下文线程被占用，则会进行等待直到被释放。
	- 未捕获上下文时，则会随机分配一个新的线程继续执行任务。

## 总结
### 为什么 `async await` 是单线程执行
将 `FunAsync`看作一个整体，执行到 `await` 时，`FunAsync` 会被标记暂停，载体 `FunThread` 会被分配去执行其它任务，直到 `await` 返回后，任务调度器会根据上下文分配一个 `Thread`（捕获上下文通常会分配原先的线程） 继续执行 `FunAsync`。从始至终，Async未被分割成多个部分在不同线程执行，所以是单线程执行。